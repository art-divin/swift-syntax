//// Automatically generated by generate-swift-syntax
//// Do not edit directly!
//===----------------------------------------------------------------------===//
//
// This source file is part of the Swift.org open source project
//
// Copyright (c) 2014 - 2023 Apple Inc. and the Swift project authors
// Licensed under Apache License v2.0 with Runtime Library Exception
//
// See https://swift.org/LICENSE.txt for license information
// See https://swift.org/CONTRIBUTORS.txt for the list of Swift project authors
//
//===----------------------------------------------------------------------===//

// MARK: - ExprSyntax

/// Protocol to which all ``ExprSyntax`` nodes conform.
///
/// Extension point to add common methods to all ``ExprSyntax`` nodes.
///
///  - Warning: Do not conform to this protocol yourself.
public protocol ExprSyntaxProtocol: SyntaxProtocol {}

/// Extension of ``ExprSyntaxProtocol`` to provide casting methods.
///
/// These methods enable casting between syntax node types within the same
/// base node protocol hierarchy (e.g., ``DeclSyntaxProtocol``).
///
/// While ``SyntaxProtocol`` offers general casting methods (``SyntaxProtocol.as(_:)``,
/// ``SyntaxProtocol.is(_:)``, and ``SyntaxProtocol.cast(_:)``), these often aren't
/// appropriate for use on types conforming to a specific base node protocol
/// like ``ExprSyntaxProtocol``. That's because at this level,
/// we know that the cast to another base node type (e.g., ``DeclSyntaxProtocol``
/// when working with ``ExprSyntaxProtocol``) is guaranteed to fail.
///
/// To guide developers toward correct usage, this extension provides overloads
/// of these casting methods that are restricted to the same base node type.
/// Furthermore, it marks the inherited casting methods from ``SyntaxProtocol`` as
/// deprecated, indicating that they will always fail when used in this context.
extension ExprSyntaxProtocol {
  /// Checks if the current syntax node can be cast to a given specialized syntax type.
  ///
  /// - Returns: `true` if the node can be cast, `false` otherwise.
  public func `is`<S: ExprSyntaxProtocol>(_ syntaxType: S.Type) -> Bool {
    return self.as(syntaxType) != nil
  }
  

  /// Attempts to cast the current syntax node to a given specialized syntax type.
  ///
  /// - Returns: An instance of the specialized type, or `nil` if the cast fails.
  public func `as`<S: ExprSyntaxProtocol>(_ syntaxType: S.Type) -> S? {
    return S.init(self)
  }
  

  /// Force-casts the current syntax node to a given specialized syntax type.
  ///
  /// - Returns: An instance of the specialized type.
  ///
  /// - Warning: This function will crash if the cast is not possible. Use `as` to safely attempt a cast.
  public func cast<S: ExprSyntaxProtocol>(_ syntaxType: S.Type) -> S {
    return self.as(S.self)!
  }
  

  /// Checks if the current syntax node can be upcast to its base node type (``ExprSyntax``).
  ///
  /// - Returns: `true` since the node can always be upcast to its base node.
  @available(*, deprecated, message: "This cast will always succeed")
  public func `is`(_ syntaxType: ExprSyntax.Type) -> Bool {
    return true
  }
  

  /// Attempts to upcast the current syntax node to its base node type (``ExprSyntax``).
  ///
  /// - Returns: The base node created from the current syntax node, as the node can always be upcast to its base type.
  @available(*, deprecated, message: "Use `ExprSyntax.init` for upcasting")
  public func `as`(_ syntaxType: ExprSyntax.Type) -> ExprSyntax? {
    return ExprSyntax(self)
  }
  

  /// Force-upcast the current syntax node to its base node type (``ExprSyntax``).
  ///
  /// - Returns: The base node created from the current syntax node, as the node can always be upcast to its base type.
  @available(*, deprecated, message: "Use `ExprSyntax.init` for upcasting")
  public func cast(_ syntaxType: ExprSyntax.Type) -> ExprSyntax {
    return ExprSyntax(self)
  }
  

  /// Checks if the current syntax node can be cast to a given node type from a base node protocol hierarchy other
  /// than ``ExprSyntaxProtocol``.
  ///
  /// - Returns: `true` if the node can be cast, `false` otherwise.
  ///
  /// - Note: In most cases, this is comparing a ``ExprSyntaxProtocol`` to a node that is not a
  ///   ``ExprSyntaxProtocol``, which will always fail. If the `syntaxType` argument is a generic type,
  ///   constrain it to ``ExprSyntaxProtocol`` instead of ``SyntaxProtocol``.
  @available(*, deprecated, message: "Type argument should be part of the 'ExprSyntaxProtocol' hierarchy")
  public func `is`<S: SyntaxProtocol>(_ syntaxType: S.Type) -> Bool {
    return self.as(syntaxType) != nil
  }
  

  /// Attempts to cast the current syntax node to a given node type from the a base node protocol hierarchy other than
  /// ``ExprSyntaxProtocol``.
  ///
  /// - Returns: An instance of the specialized type, or `nil` if the cast fails.
  ///
  /// - Note: In most cases, this is casting a ``ExprSyntaxProtocol`` to a node that is not a
  ///   ``ExprSyntaxProtocol``, which will always fail. If the `syntaxType` argument is a generic type,
  ///   constrain it to ``ExprSyntaxProtocol`` instead of ``SyntaxProtocol``.
  @available(*, deprecated, message: "Type argument should be part of the 'ExprSyntaxProtocol' hierarchy")
  public func `as`<S: SyntaxProtocol>(_ syntaxType: S.Type) -> S? {
    return S.init(self)
  }
  

  /// Force-casts the current syntax node to a given node type from a base node protocol hierarchy other than
  /// ``ExprSyntaxProtocol``.
  ///
  /// - Returns: An instance of the specialized type.
  ///
  /// - Warning: This function will crash if the cast is not possible. Use `as` to safely attempt a cast.
  ///
  /// - Note: In most cases, this is casting a ``ExprSyntaxProtocol`` to a node that is not a
  ///   ``ExprSyntaxProtocol``, which will always fail. If the `syntaxType` argument is a generic type,
  ///   constrain it to ``ExprSyntaxProtocol`` instead of ``SyntaxProtocol``.
  @available(*, deprecated, message: "Type argument should be part of the 'ExprSyntaxProtocol' hierarchy")
  public func cast<S: SyntaxProtocol>(_ syntaxType: S.Type) -> S {
    return self.as(S.self)!
  }
}

public extension Syntax {
  /// Check whether the non-type erased version of this syntax node conforms to
  /// ExprSyntaxProtocol.
  ///
  ///  - Note:  This will incur an existential conversion.
  func isProtocol(_: ExprSyntaxProtocol.Protocol) -> Bool {
    return self.asProtocol(ExprSyntaxProtocol.self) != nil
  }
  
  /// Return the non-type erased version of this syntax node if it conforms to
  /// ExprSyntaxProtocol. Otherwise return nil.
  ///
  ///  - Note:  This will incur an existential conversion.
  func asProtocol(_: ExprSyntaxProtocol.Protocol) -> ExprSyntaxProtocol? {
    return self.asProtocol(SyntaxProtocol.self) as? ExprSyntaxProtocol
  }
}

/// ### Subtypes
/// 
/// - ``ArrayExprSyntax``
/// - ``ArrowExprSyntax``
/// - ``AsExprSyntax``
/// - ``AssignmentExprSyntax``
/// - ``AwaitExprSyntax``
/// - ``BinaryOperatorExprSyntax``
/// - ``BooleanLiteralExprSyntax``
/// - ``BorrowExprSyntax``
/// - ``CanImportExprSyntax``
/// - ``CanImportVersionInfoSyntax``
/// - ``ClosureExprSyntax``
/// - ``ConsumeExprSyntax``
/// - ``CopyExprSyntax``
/// - ``DeclReferenceExprSyntax``
/// - ``DictionaryExprSyntax``
/// - ``DiscardAssignmentExprSyntax``
/// - ``EditorPlaceholderExprSyntax``
/// - ``FloatLiteralExprSyntax``
/// - ``ForceUnwrapExprSyntax``
/// - ``FunctionCallExprSyntax``
/// - ``GenericSpecializationExprSyntax``
/// - ``IfExprSyntax``
/// - ``InOutExprSyntax``
/// - ``InfixOperatorExprSyntax``
/// - ``IntegerLiteralExprSyntax``
/// - ``IsExprSyntax``
/// - ``KeyPathExprSyntax``
/// - ``MacroExpansionExprSyntax``
/// - ``MemberAccessExprSyntax``
/// - ``MissingExprSyntax``
/// - ``NilLiteralExprSyntax``
/// - ``OptionalChainingExprSyntax``
/// - ``PackElementExprSyntax``
/// - ``PackExpansionExprSyntax``
/// - ``PatternExprSyntax``
/// - ``PostfixIfConfigExprSyntax``
/// - ``PostfixOperatorExprSyntax``
/// - ``PrefixOperatorExprSyntax``
/// - ``RegexLiteralExprSyntax``
/// - ``SequenceExprSyntax``
/// - ``SimpleStringLiteralExprSyntax``
/// - ``StringLiteralExprSyntax``
/// - ``SubscriptCallExprSyntax``
/// - ``SuperExprSyntax``
/// - ``SwitchExprSyntax``
/// - ``TernaryExprSyntax``
/// - ``TryExprSyntax``
/// - ``TupleExprSyntax``
/// - ``TypeExprSyntax``
/// - ``UnresolvedAsExprSyntax``
/// - ``UnresolvedIsExprSyntax``
/// - ``UnresolvedTernaryExprSyntax``
public struct ExprSyntax: ExprSyntaxProtocol, SyntaxHashable {
  public let _syntaxNode: Syntax
  
  /// Create a ``ExprSyntax`` node from a specialized syntax node.
  public init(_ syntax: some ExprSyntaxProtocol) {
    // We know this cast is going to succeed. Go through init(_: SyntaxData)
    // to do a sanity check and verify the kind matches in debug builds and get
    // maximum performance in release builds.
    self = Syntax(syntax).cast(Self.self)
  }
  
  /// Create a ``ExprSyntax`` node from a specialized optional syntax node.
  public init?(_ syntax: (some ExprSyntaxProtocol)?) {
    guard let syntax = syntax else {
      return nil
    }
    self.init(syntax)
  }
  
  public init(fromProtocol syntax: ExprSyntaxProtocol) {
    // We know this cast is going to succeed. Go through init(_: SyntaxData)
    // to do a sanity check and verify the kind matches in debug builds and get
    // maximum performance in release builds.
    self = Syntax(syntax).cast(Self.self)
  }
  
  /// Create a ``ExprSyntax`` node from a specialized optional syntax node.
  public init?(fromProtocol syntax: ExprSyntaxProtocol?) {
    guard let syntax = syntax else {
      return nil
    }
    self.init(fromProtocol: syntax)
  }
  
  public init?(_ node: some SyntaxProtocol) {
    switch node.raw.kind {
    case .arrayExpr, .arrowExpr, .asExpr, .assignmentExpr, .awaitExpr, .binaryOperatorExpr, .booleanLiteralExpr, .borrowExpr, .canImportExpr, .canImportVersionInfo, .closureExpr, .consumeExpr, .copyExpr, .declReferenceExpr, .dictionaryExpr, .discardAssignmentExpr, .doExpr, .editorPlaceholderExpr, .floatLiteralExpr, .forceUnwrapExpr, .functionCallExpr, .genericSpecializationExpr, .ifExpr, .inOutExpr, .infixOperatorExpr, .integerLiteralExpr, .isExpr, .keyPathExpr, .macroExpansionExpr, .memberAccessExpr, .missingExpr, .nilLiteralExpr, .optionalChainingExpr, .packElementExpr, .packExpansionExpr, .patternExpr, .postfixIfConfigExpr, .postfixOperatorExpr, .prefixOperatorExpr, .regexLiteralExpr, .sequenceExpr, .simpleStringLiteralExpr, .stringLiteralExpr, .subscriptCallExpr, .superExpr, .switchExpr, .ternaryExpr, .tryExpr, .tupleExpr, .typeExpr, .unresolvedAsExpr, .unresolvedIsExpr, .unresolvedTernaryExpr:
      self._syntaxNode = node._syntaxNode
    default:
      return nil
    }
  }
  
  /// Syntax nodes always conform to `ExprSyntaxProtocol`. This API is just
  /// added for consistency.
  ///
  ///  - Note:  This will incur an existential conversion.
  @available(*, deprecated, message: "Expression always evaluates to true")
  public func isProtocol(_: ExprSyntaxProtocol.Protocol) -> Bool {
    return true
  }
  
  /// Return the non-type erased version of this syntax node.
  ///
  ///  - Note:  This will incur an existential conversion.
  public func asProtocol(_: ExprSyntaxProtocol.Protocol) -> ExprSyntaxProtocol {
    return Syntax(self).asProtocol(ExprSyntaxProtocol.self)!
  }
  
  public static var structure: SyntaxNodeStructure {
    return .choices([
          .node(ArrayExprSyntax.self),
          .node(ArrowExprSyntax.self),
          .node(AsExprSyntax.self),
          .node(AssignmentExprSyntax.self),
          .node(AwaitExprSyntax.self),
          .node(BinaryOperatorExprSyntax.self),
          .node(BooleanLiteralExprSyntax.self),
          .node(BorrowExprSyntax.self),
          .node(CanImportExprSyntax.self),
          .node(CanImportVersionInfoSyntax.self),
          .node(ClosureExprSyntax.self),
          .node(ConsumeExprSyntax.self),
          .node(CopyExprSyntax.self),
          .node(DeclReferenceExprSyntax.self),
          .node(DictionaryExprSyntax.self),
          .node(DiscardAssignmentExprSyntax.self),
          .node(DoExprSyntax.self),
          .node(EditorPlaceholderExprSyntax.self),
          .node(FloatLiteralExprSyntax.self),
          .node(ForceUnwrapExprSyntax.self),
          .node(FunctionCallExprSyntax.self),
          .node(GenericSpecializationExprSyntax.self),
          .node(IfExprSyntax.self),
          .node(InOutExprSyntax.self),
          .node(InfixOperatorExprSyntax.self),
          .node(IntegerLiteralExprSyntax.self),
          .node(IsExprSyntax.self),
          .node(KeyPathExprSyntax.self),
          .node(MacroExpansionExprSyntax.self),
          .node(MemberAccessExprSyntax.self),
          .node(MissingExprSyntax.self),
          .node(NilLiteralExprSyntax.self),
          .node(OptionalChainingExprSyntax.self),
          .node(PackElementExprSyntax.self),
          .node(PackExpansionExprSyntax.self),
          .node(PatternExprSyntax.self),
          .node(PostfixIfConfigExprSyntax.self),
          .node(PostfixOperatorExprSyntax.self),
          .node(PrefixOperatorExprSyntax.self),
          .node(RegexLiteralExprSyntax.self),
          .node(SequenceExprSyntax.self),
          .node(SimpleStringLiteralExprSyntax.self),
          .node(StringLiteralExprSyntax.self),
          .node(SubscriptCallExprSyntax.self),
          .node(SuperExprSyntax.self),
          .node(SwitchExprSyntax.self),
          .node(TernaryExprSyntax.self),
          .node(TryExprSyntax.self),
          .node(TupleExprSyntax.self),
          .node(TypeExprSyntax.self),
          .node(UnresolvedAsExprSyntax.self),
          .node(UnresolvedIsExprSyntax.self),
          .node(UnresolvedTernaryExprSyntax.self)
        ])
  }
}

/// Protocol that syntax nodes conform to if they don't have any semantic subtypes.
/// These are syntax nodes that are not considered base nodes for other syntax types.
///
/// Syntax nodes conforming to this protocol have their inherited casting methods
/// deprecated to prevent incorrect casting.
public protocol _LeafExprSyntaxNodeProtocol: ExprSyntaxProtocol {}

public extension _LeafExprSyntaxNodeProtocol {
  /// Checks if the current leaf syntax node can be cast to a different specified type.
  ///
  /// - Returns: `false` since the leaf node cannot be cast to a different specified type.
  ///
  /// - Note: This method overloads the general `is` method and is marked as deprecated to produce a warning,
  ///         informing the user that the cast will always fail.
  @available(*, deprecated, message: "This cast will always fail")
  func `is`<S: ExprSyntaxProtocol>(_ syntaxType: S.Type) -> Bool {
    return false
  }
  

  /// Attempts to cast the current leaf syntax node to a different specified type.
  ///
  /// - Returns: `nil` since the leaf node cannot be cast to a different specified type.
  ///
  /// - Note: This method overloads the general `as` method and is marked as deprecated to produce a warning,
  ///         informing the user that the cast will always fail.
  @available(*, deprecated, message: "This cast will always fail")
  func `as`<S: ExprSyntaxProtocol>(_ syntaxType: S.Type) -> S? {
    return nil
  }
  

  /// Force-casts the current leaf syntax node to a different specified type.
  ///
  /// - Returns: This method will always trigger a runtime crash and never return.
  ///
  /// - Note: This method overloads the general `cast` method and is marked as deprecated to produce a warning,
  ///         informing the user that the cast will always fail.
  /// - Warning: Invoking this method will lead to a fatal error.
  @available(*, deprecated, message: "This cast will always fail")
  func cast<S: ExprSyntaxProtocol>(_ syntaxType: S.Type) -> S {
    fatalError("\(Self.self) cannot be cast to \(S.self)")
  }
}
