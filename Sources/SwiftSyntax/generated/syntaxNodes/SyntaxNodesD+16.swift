//// Automatically generated by generate-swift-syntax
//// Do not edit directly!
//===----------------------------------------------------------------------===//
//
// This source file is part of the Swift.org open source project
//
// Copyright (c) 2014 - 2023 Apple Inc. and the Swift project authors
// Licensed under Apache License v2.0 with Runtime Library Exception
//
// See https://swift.org/LICENSE.txt for license information
// See https://swift.org/CONTRIBUTORS.txt for the list of Swift project authors
//
//===----------------------------------------------------------------------===//

// MARK: - DifferentiableAttributeArgumentsSyntax

/// The arguments for the `@differentiable` attribute: an optional differentiability kind, an optional differentiability parameter clause, and an optional 'where' clause.
///
/// ### Children
/// 
///  - `kindSpecifier`: (`_forward` | `reverse` | `_linear`)?
///  - `kindSpecifierComma`: `,`?
///  - `arguments`: ``DifferentiabilityWithRespectToArgumentSyntax``?
///  - `argumentsComma`: `,`?
///  - `genericWhereClause`: ``GenericWhereClauseSyntax``?
///
/// ### Contained in
/// 
///  - ``AttributeSyntax``.``AttributeSyntax/arguments``
public struct DifferentiableAttributeArgumentsSyntax: SyntaxProtocol, SyntaxHashable, _LeafSyntaxNodeProtocol {
  public let _syntaxNode: Syntax
  
  public init?(_ node: some SyntaxProtocol) {
    guard node.raw.kind == .differentiableAttributeArguments else {
      return nil
    }
    self._syntaxNode = node._syntaxNode
  }
  
  /// - Parameters:
  ///   - leadingTrivia: Trivia to be prepended to the leading trivia of the node’s first token. If the node is empty, there is no token to attach the trivia to and the parameter is ignored.
  ///   - kindSpecifierComma: The comma following the differentiability kind, if it exists.
  ///   - argumentsComma: The comma following the differentiability arguments clause, if it exists.
  ///   - genericWhereClause: A `where` clause that places additional constraints on generic parameters like `where T: Differentiable`.
  ///   - trailingTrivia: Trivia to be appended to the trailing trivia of the node’s last token. If the node is empty, there is no token to attach the trivia to and the parameter is ignored.
  public init(
      leadingTrivia: Trivia? = nil,
      _ unexpectedBeforeKindSpecifier: UnexpectedNodesSyntax? = nil,
      kindSpecifier: TokenSyntax? = nil,
      _ unexpectedBetweenKindSpecifierAndKindSpecifierComma: UnexpectedNodesSyntax? = nil,
      kindSpecifierComma: TokenSyntax? = nil,
      _ unexpectedBetweenKindSpecifierCommaAndArguments: UnexpectedNodesSyntax? = nil,
      arguments: DifferentiabilityWithRespectToArgumentSyntax? = nil,
      _ unexpectedBetweenArgumentsAndArgumentsComma: UnexpectedNodesSyntax? = nil,
      argumentsComma: TokenSyntax? = nil,
      _ unexpectedBetweenArgumentsCommaAndGenericWhereClause: UnexpectedNodesSyntax? = nil,
      genericWhereClause: GenericWhereClauseSyntax? = nil,
      _ unexpectedAfterGenericWhereClause: UnexpectedNodesSyntax? = nil,
      trailingTrivia: Trivia? = nil
    
  ) {
    // Extend the lifetime of all parameters so their arenas don't get destroyed
    // before they can be added as children of the new arena.
    self = withExtendedLifetime((SyntaxArena(), (
            unexpectedBeforeKindSpecifier, 
            kindSpecifier, 
            unexpectedBetweenKindSpecifierAndKindSpecifierComma, 
            kindSpecifierComma, 
            unexpectedBetweenKindSpecifierCommaAndArguments, 
            arguments, 
            unexpectedBetweenArgumentsAndArgumentsComma, 
            argumentsComma, 
            unexpectedBetweenArgumentsCommaAndGenericWhereClause, 
            genericWhereClause, 
            unexpectedAfterGenericWhereClause
          ))) { (arena, _) in
      let layout: [RawSyntax?] = [
          unexpectedBeforeKindSpecifier?.raw, 
          kindSpecifier?.raw, 
          unexpectedBetweenKindSpecifierAndKindSpecifierComma?.raw, 
          kindSpecifierComma?.raw, 
          unexpectedBetweenKindSpecifierCommaAndArguments?.raw, 
          arguments?.raw, 
          unexpectedBetweenArgumentsAndArgumentsComma?.raw, 
          argumentsComma?.raw, 
          unexpectedBetweenArgumentsCommaAndGenericWhereClause?.raw, 
          genericWhereClause?.raw, 
          unexpectedAfterGenericWhereClause?.raw
        ]
      let raw = RawSyntax.makeLayout(
        kind: SyntaxKind.differentiableAttributeArguments,
        from: layout,
        arena: arena,
        leadingTrivia: leadingTrivia,
        trailingTrivia: trailingTrivia
        
      )
      return Syntax.forRoot(raw, rawNodeArena: arena).cast(Self.self)
    }
  }
  
  public var unexpectedBeforeKindSpecifier: UnexpectedNodesSyntax? {
    get {
      return Syntax(self).child(at: 0)?.cast(UnexpectedNodesSyntax.self)
    }
    set(value) {
      self = Syntax(self).replacingChild(at: 0, with: Syntax(value), arena: SyntaxArena()).cast(DifferentiableAttributeArgumentsSyntax.self)
    }
  }
  
  /// ### Tokens
  /// 
  /// For syntax trees generated by the parser, this is guaranteed to be one of the following kinds:
  ///  - `_forward`
  ///  - `reverse`
  ///  - `_linear`
  public var kindSpecifier: TokenSyntax? {
    get {
      return Syntax(self).child(at: 1)?.cast(TokenSyntax.self)
    }
    set(value) {
      self = Syntax(self).replacingChild(at: 1, with: Syntax(value), arena: SyntaxArena()).cast(DifferentiableAttributeArgumentsSyntax.self)
    }
  }
  
  public var unexpectedBetweenKindSpecifierAndKindSpecifierComma: UnexpectedNodesSyntax? {
    get {
      return Syntax(self).child(at: 2)?.cast(UnexpectedNodesSyntax.self)
    }
    set(value) {
      self = Syntax(self).replacingChild(at: 2, with: Syntax(value), arena: SyntaxArena()).cast(DifferentiableAttributeArgumentsSyntax.self)
    }
  }
  
  /// The comma following the differentiability kind, if it exists.
  ///
  /// ### Tokens
  /// 
  /// For syntax trees generated by the parser, this is guaranteed to be `,`.
  public var kindSpecifierComma: TokenSyntax? {
    get {
      return Syntax(self).child(at: 3)?.cast(TokenSyntax.self)
    }
    set(value) {
      self = Syntax(self).replacingChild(at: 3, with: Syntax(value), arena: SyntaxArena()).cast(DifferentiableAttributeArgumentsSyntax.self)
    }
  }
  
  public var unexpectedBetweenKindSpecifierCommaAndArguments: UnexpectedNodesSyntax? {
    get {
      return Syntax(self).child(at: 4)?.cast(UnexpectedNodesSyntax.self)
    }
    set(value) {
      self = Syntax(self).replacingChild(at: 4, with: Syntax(value), arena: SyntaxArena()).cast(DifferentiableAttributeArgumentsSyntax.self)
    }
  }
  
  public var arguments: DifferentiabilityWithRespectToArgumentSyntax? {
    get {
      return Syntax(self).child(at: 5)?.cast(DifferentiabilityWithRespectToArgumentSyntax.self)
    }
    set(value) {
      self = Syntax(self).replacingChild(at: 5, with: Syntax(value), arena: SyntaxArena()).cast(DifferentiableAttributeArgumentsSyntax.self)
    }
  }
  
  public var unexpectedBetweenArgumentsAndArgumentsComma: UnexpectedNodesSyntax? {
    get {
      return Syntax(self).child(at: 6)?.cast(UnexpectedNodesSyntax.self)
    }
    set(value) {
      self = Syntax(self).replacingChild(at: 6, with: Syntax(value), arena: SyntaxArena()).cast(DifferentiableAttributeArgumentsSyntax.self)
    }
  }
  
  /// The comma following the differentiability arguments clause, if it exists.
  ///
  /// ### Tokens
  /// 
  /// For syntax trees generated by the parser, this is guaranteed to be `,`.
  public var argumentsComma: TokenSyntax? {
    get {
      return Syntax(self).child(at: 7)?.cast(TokenSyntax.self)
    }
    set(value) {
      self = Syntax(self).replacingChild(at: 7, with: Syntax(value), arena: SyntaxArena()).cast(DifferentiableAttributeArgumentsSyntax.self)
    }
  }
  
  public var unexpectedBetweenArgumentsCommaAndGenericWhereClause: UnexpectedNodesSyntax? {
    get {
      return Syntax(self).child(at: 8)?.cast(UnexpectedNodesSyntax.self)
    }
    set(value) {
      self = Syntax(self).replacingChild(at: 8, with: Syntax(value), arena: SyntaxArena()).cast(DifferentiableAttributeArgumentsSyntax.self)
    }
  }
  
  /// A `where` clause that places additional constraints on generic parameters like `where T: Differentiable`.
  public var genericWhereClause: GenericWhereClauseSyntax? {
    get {
      return Syntax(self).child(at: 9)?.cast(GenericWhereClauseSyntax.self)
    }
    set(value) {
      self = Syntax(self).replacingChild(at: 9, with: Syntax(value), arena: SyntaxArena()).cast(DifferentiableAttributeArgumentsSyntax.self)
    }
  }
  
  public var unexpectedAfterGenericWhereClause: UnexpectedNodesSyntax? {
    get {
      return Syntax(self).child(at: 10)?.cast(UnexpectedNodesSyntax.self)
    }
    set(value) {
      self = Syntax(self).replacingChild(at: 10, with: Syntax(value), arena: SyntaxArena()).cast(DifferentiableAttributeArgumentsSyntax.self)
    }
  }
  
  public static var structure: SyntaxNodeStructure {
    return .layout([
          \Self.unexpectedBeforeKindSpecifier, 
          \Self.kindSpecifier, 
          \Self.unexpectedBetweenKindSpecifierAndKindSpecifierComma, 
          \Self.kindSpecifierComma, 
          \Self.unexpectedBetweenKindSpecifierCommaAndArguments, 
          \Self.arguments, 
          \Self.unexpectedBetweenArgumentsAndArgumentsComma, 
          \Self.argumentsComma, 
          \Self.unexpectedBetweenArgumentsCommaAndGenericWhereClause, 
          \Self.genericWhereClause, 
          \Self.unexpectedAfterGenericWhereClause
        ])
  }
}
