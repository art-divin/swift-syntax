//// Automatically generated by generate-swift-syntax
//// Do not edit directly!
//===----------------------------------------------------------------------===//
//
// This source file is part of the Swift.org open source project
//
// Copyright (c) 2014 - 2023 Apple Inc. and the Swift project authors
// Licensed under Apache License v2.0 with Runtime Library Exception
//
// See https://swift.org/LICENSE.txt for license information
// See https://swift.org/CONTRIBUTORS.txt for the list of Swift project authors
//
//===----------------------------------------------------------------------===//

// MARK: - AttributeSyntax

/// An `@` attribute.
///
/// ### Children
/// 
///  - `atSign`: `@`
///  - `attributeName`: ``TypeSyntax``
///  - `leftParen`: `(`?
///  - `arguments`: (``LabeledExprListSyntax`` | ``TokenSyntax`` | ``StringLiteralExprSyntax`` | ``AvailabilityArgumentListSyntax`` | ``SpecializeAttributeArgumentListSyntax`` | ``ObjCSelectorPieceListSyntax`` | ``ImplementsAttributeArgumentsSyntax`` | ``DifferentiableAttributeArgumentsSyntax`` | ``DerivativeAttributeArgumentsSyntax`` | ``BackDeployedAttributeArgumentsSyntax`` | ``ConventionAttributeArgumentsSyntax`` | ``ConventionWitnessMethodAttributeArgumentsSyntax`` | ``OpaqueReturnTypeOfAttributeArgumentsSyntax`` | ``ExposeAttributeArgumentsSyntax`` | ``OriginallyDefinedInAttributeArgumentsSyntax`` | ``UnderscorePrivateAttributeArgumentsSyntax`` | ``DynamicReplacementAttributeArgumentsSyntax`` | ``UnavailableFromAsyncAttributeArgumentsSyntax`` | ``EffectsAttributeArgumentListSyntax`` | ``DocumentationAttributeArgumentListSyntax``)?
///  - `rightParen`: `)`?
///
/// ### Contained in
/// 
///  - ``AttributeListSyntax``
///  - ``SwitchCaseSyntax``.``SwitchCaseSyntax/attribute``
public struct AttributeSyntax: SyntaxProtocol, SyntaxHashable, _LeafSyntaxNodeProtocol {
  public enum Arguments: SyntaxChildChoices, SyntaxHashable {
    case `argumentList`(LabeledExprListSyntax)
    case `token`(TokenSyntax)
    case `string`(StringLiteralExprSyntax)
    case `availability`(AvailabilityArgumentListSyntax)
    case `specializeArguments`(SpecializeAttributeArgumentListSyntax)
    case `objCName`(ObjCSelectorPieceListSyntax)
    case `implementsArguments`(ImplementsAttributeArgumentsSyntax)
    case `differentiableArguments`(DifferentiableAttributeArgumentsSyntax)
    case `derivativeRegistrationArguments`(DerivativeAttributeArgumentsSyntax)
    case `backDeployedArguments`(BackDeployedAttributeArgumentsSyntax)
    case `conventionArguments`(ConventionAttributeArgumentsSyntax)
    case `conventionWitnessMethodArguments`(ConventionWitnessMethodAttributeArgumentsSyntax)
    case `opaqueReturnTypeOfAttributeArguments`(OpaqueReturnTypeOfAttributeArgumentsSyntax)
    case `exposeAttributeArguments`(ExposeAttributeArgumentsSyntax)
    case `originallyDefinedInArguments`(OriginallyDefinedInAttributeArgumentsSyntax)
    case `underscorePrivateAttributeArguments`(UnderscorePrivateAttributeArgumentsSyntax)
    case `dynamicReplacementArguments`(DynamicReplacementAttributeArgumentsSyntax)
    case `unavailableFromAsyncArguments`(UnavailableFromAsyncAttributeArgumentsSyntax)
    case `effectsArguments`(EffectsAttributeArgumentListSyntax)
    case `documentationArguments`(DocumentationAttributeArgumentListSyntax)
    
    public var _syntaxNode: Syntax {
      switch self {
      case .argumentList(let node):
        return node._syntaxNode
      case .token(let node):
        return node._syntaxNode
      case .string(let node):
        return node._syntaxNode
      case .availability(let node):
        return node._syntaxNode
      case .specializeArguments(let node):
        return node._syntaxNode
      case .objCName(let node):
        return node._syntaxNode
      case .implementsArguments(let node):
        return node._syntaxNode
      case .differentiableArguments(let node):
        return node._syntaxNode
      case .derivativeRegistrationArguments(let node):
        return node._syntaxNode
      case .backDeployedArguments(let node):
        return node._syntaxNode
      case .conventionArguments(let node):
        return node._syntaxNode
      case .conventionWitnessMethodArguments(let node):
        return node._syntaxNode
      case .opaqueReturnTypeOfAttributeArguments(let node):
        return node._syntaxNode
      case .exposeAttributeArguments(let node):
        return node._syntaxNode
      case .originallyDefinedInArguments(let node):
        return node._syntaxNode
      case .underscorePrivateAttributeArguments(let node):
        return node._syntaxNode
      case .dynamicReplacementArguments(let node):
        return node._syntaxNode
      case .unavailableFromAsyncArguments(let node):
        return node._syntaxNode
      case .effectsArguments(let node):
        return node._syntaxNode
      case .documentationArguments(let node):
        return node._syntaxNode
      }
    }
    
    public init(_ node: LabeledExprListSyntax) {
      self = .argumentList(node)
    }
    
    public init(_ node: TokenSyntax) {
      self = .token(node)
    }
    
    public init(_ node: StringLiteralExprSyntax) {
      self = .string(node)
    }
    
    public init(_ node: AvailabilityArgumentListSyntax) {
      self = .availability(node)
    }
    
    public init(_ node: SpecializeAttributeArgumentListSyntax) {
      self = .specializeArguments(node)
    }
    
    public init(_ node: ObjCSelectorPieceListSyntax) {
      self = .objCName(node)
    }
    
    public init(_ node: ImplementsAttributeArgumentsSyntax) {
      self = .implementsArguments(node)
    }
    
    public init(_ node: DifferentiableAttributeArgumentsSyntax) {
      self = .differentiableArguments(node)
    }
    
    public init(_ node: DerivativeAttributeArgumentsSyntax) {
      self = .derivativeRegistrationArguments(node)
    }
    
    public init(_ node: BackDeployedAttributeArgumentsSyntax) {
      self = .backDeployedArguments(node)
    }
    
    public init(_ node: ConventionAttributeArgumentsSyntax) {
      self = .conventionArguments(node)
    }
    
    public init(_ node: ConventionWitnessMethodAttributeArgumentsSyntax) {
      self = .conventionWitnessMethodArguments(node)
    }
    
    public init(_ node: OpaqueReturnTypeOfAttributeArgumentsSyntax) {
      self = .opaqueReturnTypeOfAttributeArguments(node)
    }
    
    public init(_ node: ExposeAttributeArgumentsSyntax) {
      self = .exposeAttributeArguments(node)
    }
    
    public init(_ node: OriginallyDefinedInAttributeArgumentsSyntax) {
      self = .originallyDefinedInArguments(node)
    }
    
    public init(_ node: UnderscorePrivateAttributeArgumentsSyntax) {
      self = .underscorePrivateAttributeArguments(node)
    }
    
    public init(_ node: DynamicReplacementAttributeArgumentsSyntax) {
      self = .dynamicReplacementArguments(node)
    }
    
    public init(_ node: UnavailableFromAsyncAttributeArgumentsSyntax) {
      self = .unavailableFromAsyncArguments(node)
    }
    
    public init(_ node: EffectsAttributeArgumentListSyntax) {
      self = .effectsArguments(node)
    }
    
    public init(_ node: DocumentationAttributeArgumentListSyntax) {
      self = .documentationArguments(node)
    }
    
    public init?(_ node: some SyntaxProtocol) {
      if let node = node.as(LabeledExprListSyntax.self) {
        self = .argumentList(node)
        return
      }
      if let node = node.as(TokenSyntax.self) {
        self = .token(node)
        return
      }
      if let node = node.as(StringLiteralExprSyntax.self) {
        self = .string(node)
        return
      }
      if let node = node.as(AvailabilityArgumentListSyntax.self) {
        self = .availability(node)
        return
      }
      if let node = node.as(SpecializeAttributeArgumentListSyntax.self) {
        self = .specializeArguments(node)
        return
      }
      if let node = node.as(ObjCSelectorPieceListSyntax.self) {
        self = .objCName(node)
        return
      }
      if let node = node.as(ImplementsAttributeArgumentsSyntax.self) {
        self = .implementsArguments(node)
        return
      }
      if let node = node.as(DifferentiableAttributeArgumentsSyntax.self) {
        self = .differentiableArguments(node)
        return
      }
      if let node = node.as(DerivativeAttributeArgumentsSyntax.self) {
        self = .derivativeRegistrationArguments(node)
        return
      }
      if let node = node.as(BackDeployedAttributeArgumentsSyntax.self) {
        self = .backDeployedArguments(node)
        return
      }
      if let node = node.as(ConventionAttributeArgumentsSyntax.self) {
        self = .conventionArguments(node)
        return
      }
      if let node = node.as(ConventionWitnessMethodAttributeArgumentsSyntax.self) {
        self = .conventionWitnessMethodArguments(node)
        return
      }
      if let node = node.as(OpaqueReturnTypeOfAttributeArgumentsSyntax.self) {
        self = .opaqueReturnTypeOfAttributeArguments(node)
        return
      }
      if let node = node.as(ExposeAttributeArgumentsSyntax.self) {
        self = .exposeAttributeArguments(node)
        return
      }
      if let node = node.as(OriginallyDefinedInAttributeArgumentsSyntax.self) {
        self = .originallyDefinedInArguments(node)
        return
      }
      if let node = node.as(UnderscorePrivateAttributeArgumentsSyntax.self) {
        self = .underscorePrivateAttributeArguments(node)
        return
      }
      if let node = node.as(DynamicReplacementAttributeArgumentsSyntax.self) {
        self = .dynamicReplacementArguments(node)
        return
      }
      if let node = node.as(UnavailableFromAsyncAttributeArgumentsSyntax.self) {
        self = .unavailableFromAsyncArguments(node)
        return
      }
      if let node = node.as(EffectsAttributeArgumentListSyntax.self) {
        self = .effectsArguments(node)
        return
      }
      if let node = node.as(DocumentationAttributeArgumentListSyntax.self) {
        self = .documentationArguments(node)
        return
      }
      return nil
    }
    
    public static var structure: SyntaxNodeStructure {
      return .choices([
            .node(LabeledExprListSyntax.self), 
            .node(TokenSyntax.self), 
            .node(StringLiteralExprSyntax.self), 
            .node(AvailabilityArgumentListSyntax.self), 
            .node(SpecializeAttributeArgumentListSyntax.self), 
            .node(ObjCSelectorPieceListSyntax.self), 
            .node(ImplementsAttributeArgumentsSyntax.self), 
            .node(DifferentiableAttributeArgumentsSyntax.self), 
            .node(DerivativeAttributeArgumentsSyntax.self), 
            .node(BackDeployedAttributeArgumentsSyntax.self), 
            .node(ConventionAttributeArgumentsSyntax.self), 
            .node(ConventionWitnessMethodAttributeArgumentsSyntax.self), 
            .node(OpaqueReturnTypeOfAttributeArgumentsSyntax.self), 
            .node(ExposeAttributeArgumentsSyntax.self), 
            .node(OriginallyDefinedInAttributeArgumentsSyntax.self), 
            .node(UnderscorePrivateAttributeArgumentsSyntax.self), 
            .node(DynamicReplacementAttributeArgumentsSyntax.self), 
            .node(UnavailableFromAsyncAttributeArgumentsSyntax.self), 
            .node(EffectsAttributeArgumentListSyntax.self), 
            .node(DocumentationAttributeArgumentListSyntax.self)
          ])
    }
    
    /// Checks if the current syntax node can be cast to ``LabeledExprListSyntax``.
    ///
    /// - Returns: `true` if the node can be cast, `false` otherwise.
    public func `is`(_ syntaxType: LabeledExprListSyntax.Type) -> Bool {
      return self.as(syntaxType) != nil
    }
    
    /// Attempts to cast the current syntax node to ``LabeledExprListSyntax``.
    ///
    /// - Returns: An instance of ``LabeledExprListSyntax``, or `nil` if the cast fails.
    public func `as`(_ syntaxType: LabeledExprListSyntax.Type) -> LabeledExprListSyntax? {
      return LabeledExprListSyntax.init(self)
    }
    
    /// Force-casts the current syntax node to ``LabeledExprListSyntax``.
    ///
    /// - Returns: An instance of ``LabeledExprListSyntax``.
    /// - Warning: This function will crash if the cast is not possible. Use `as` to safely attempt a cast.
    public func cast(_ syntaxType: LabeledExprListSyntax.Type) -> LabeledExprListSyntax {
      return self.as(LabeledExprListSyntax.self)!
    }
    
    /// Checks if the current syntax node can be cast to ``TokenSyntax``.
    ///
    /// - Returns: `true` if the node can be cast, `false` otherwise.
    public func `is`(_ syntaxType: TokenSyntax.Type) -> Bool {
      return self.as(syntaxType) != nil
    }
    
    /// Attempts to cast the current syntax node to ``TokenSyntax``.
    ///
    /// - Returns: An instance of ``TokenSyntax``, or `nil` if the cast fails.
    public func `as`(_ syntaxType: TokenSyntax.Type) -> TokenSyntax? {
      return TokenSyntax.init(self)
    }
    
    /// Force-casts the current syntax node to ``TokenSyntax``.
    ///
    /// - Returns: An instance of ``TokenSyntax``.
    /// - Warning: This function will crash if the cast is not possible. Use `as` to safely attempt a cast.
    public func cast(_ syntaxType: TokenSyntax.Type) -> TokenSyntax {
      return self.as(TokenSyntax.self)!
    }
    
    /// Checks if the current syntax node can be cast to ``StringLiteralExprSyntax``.
    ///
    /// - Returns: `true` if the node can be cast, `false` otherwise.
    public func `is`(_ syntaxType: StringLiteralExprSyntax.Type) -> Bool {
      return self.as(syntaxType) != nil
    }
    
    /// Attempts to cast the current syntax node to ``StringLiteralExprSyntax``.
    ///
    /// - Returns: An instance of ``StringLiteralExprSyntax``, or `nil` if the cast fails.
    public func `as`(_ syntaxType: StringLiteralExprSyntax.Type) -> StringLiteralExprSyntax? {
      return StringLiteralExprSyntax.init(self)
    }
    
    /// Force-casts the current syntax node to ``StringLiteralExprSyntax``.
    ///
    /// - Returns: An instance of ``StringLiteralExprSyntax``.
    /// - Warning: This function will crash if the cast is not possible. Use `as` to safely attempt a cast.
    public func cast(_ syntaxType: StringLiteralExprSyntax.Type) -> StringLiteralExprSyntax {
      return self.as(StringLiteralExprSyntax.self)!
    }
    
    /// Checks if the current syntax node can be cast to ``AvailabilityArgumentListSyntax``.
    ///
    /// - Returns: `true` if the node can be cast, `false` otherwise.
    public func `is`(_ syntaxType: AvailabilityArgumentListSyntax.Type) -> Bool {
      return self.as(syntaxType) != nil
    }
    
    /// Attempts to cast the current syntax node to ``AvailabilityArgumentListSyntax``.
    ///
    /// - Returns: An instance of ``AvailabilityArgumentListSyntax``, or `nil` if the cast fails.
    public func `as`(_ syntaxType: AvailabilityArgumentListSyntax.Type) -> AvailabilityArgumentListSyntax? {
      return AvailabilityArgumentListSyntax.init(self)
    }
    
    /// Force-casts the current syntax node to ``AvailabilityArgumentListSyntax``.
    ///
    /// - Returns: An instance of ``AvailabilityArgumentListSyntax``.
    /// - Warning: This function will crash if the cast is not possible. Use `as` to safely attempt a cast.
    public func cast(_ syntaxType: AvailabilityArgumentListSyntax.Type) -> AvailabilityArgumentListSyntax {
      return self.as(AvailabilityArgumentListSyntax.self)!
    }
    
    /// Checks if the current syntax node can be cast to ``SpecializeAttributeArgumentListSyntax``.
    ///
    /// - Returns: `true` if the node can be cast, `false` otherwise.
    public func `is`(_ syntaxType: SpecializeAttributeArgumentListSyntax.Type) -> Bool {
      return self.as(syntaxType) != nil
    }
    
    /// Attempts to cast the current syntax node to ``SpecializeAttributeArgumentListSyntax``.
    ///
    /// - Returns: An instance of ``SpecializeAttributeArgumentListSyntax``, or `nil` if the cast fails.
    public func `as`(_ syntaxType: SpecializeAttributeArgumentListSyntax.Type) -> SpecializeAttributeArgumentListSyntax? {
      return SpecializeAttributeArgumentListSyntax.init(self)
    }
    
    /// Force-casts the current syntax node to ``SpecializeAttributeArgumentListSyntax``.
    ///
    /// - Returns: An instance of ``SpecializeAttributeArgumentListSyntax``.
    /// - Warning: This function will crash if the cast is not possible. Use `as` to safely attempt a cast.
    public func cast(_ syntaxType: SpecializeAttributeArgumentListSyntax.Type) -> SpecializeAttributeArgumentListSyntax {
      return self.as(SpecializeAttributeArgumentListSyntax.self)!
    }
    
    /// Checks if the current syntax node can be cast to ``ObjCSelectorPieceListSyntax``.
    ///
    /// - Returns: `true` if the node can be cast, `false` otherwise.
    public func `is`(_ syntaxType: ObjCSelectorPieceListSyntax.Type) -> Bool {
      return self.as(syntaxType) != nil
    }
    
    /// Attempts to cast the current syntax node to ``ObjCSelectorPieceListSyntax``.
    ///
    /// - Returns: An instance of ``ObjCSelectorPieceListSyntax``, or `nil` if the cast fails.
    public func `as`(_ syntaxType: ObjCSelectorPieceListSyntax.Type) -> ObjCSelectorPieceListSyntax? {
      return ObjCSelectorPieceListSyntax.init(self)
    }
    
    /// Force-casts the current syntax node to ``ObjCSelectorPieceListSyntax``.
    ///
    /// - Returns: An instance of ``ObjCSelectorPieceListSyntax``.
    /// - Warning: This function will crash if the cast is not possible. Use `as` to safely attempt a cast.
    public func cast(_ syntaxType: ObjCSelectorPieceListSyntax.Type) -> ObjCSelectorPieceListSyntax {
      return self.as(ObjCSelectorPieceListSyntax.self)!
    }
    
    /// Checks if the current syntax node can be cast to ``ImplementsAttributeArgumentsSyntax``.
    ///
    /// - Returns: `true` if the node can be cast, `false` otherwise.
    public func `is`(_ syntaxType: ImplementsAttributeArgumentsSyntax.Type) -> Bool {
      return self.as(syntaxType) != nil
    }
    
    /// Attempts to cast the current syntax node to ``ImplementsAttributeArgumentsSyntax``.
    ///
    /// - Returns: An instance of ``ImplementsAttributeArgumentsSyntax``, or `nil` if the cast fails.
    public func `as`(_ syntaxType: ImplementsAttributeArgumentsSyntax.Type) -> ImplementsAttributeArgumentsSyntax? {
      return ImplementsAttributeArgumentsSyntax.init(self)
    }
    
    /// Force-casts the current syntax node to ``ImplementsAttributeArgumentsSyntax``.
    ///
    /// - Returns: An instance of ``ImplementsAttributeArgumentsSyntax``.
    /// - Warning: This function will crash if the cast is not possible. Use `as` to safely attempt a cast.
    public func cast(_ syntaxType: ImplementsAttributeArgumentsSyntax.Type) -> ImplementsAttributeArgumentsSyntax {
      return self.as(ImplementsAttributeArgumentsSyntax.self)!
    }
    
    /// Checks if the current syntax node can be cast to ``DifferentiableAttributeArgumentsSyntax``.
    ///
    /// - Returns: `true` if the node can be cast, `false` otherwise.
    public func `is`(_ syntaxType: DifferentiableAttributeArgumentsSyntax.Type) -> Bool {
      return self.as(syntaxType) != nil
    }
    
    /// Attempts to cast the current syntax node to ``DifferentiableAttributeArgumentsSyntax``.
    ///
    /// - Returns: An instance of ``DifferentiableAttributeArgumentsSyntax``, or `nil` if the cast fails.
    public func `as`(_ syntaxType: DifferentiableAttributeArgumentsSyntax.Type) -> DifferentiableAttributeArgumentsSyntax? {
      return DifferentiableAttributeArgumentsSyntax.init(self)
    }
    
    /// Force-casts the current syntax node to ``DifferentiableAttributeArgumentsSyntax``.
    ///
    /// - Returns: An instance of ``DifferentiableAttributeArgumentsSyntax``.
    /// - Warning: This function will crash if the cast is not possible. Use `as` to safely attempt a cast.
    public func cast(_ syntaxType: DifferentiableAttributeArgumentsSyntax.Type) -> DifferentiableAttributeArgumentsSyntax {
      return self.as(DifferentiableAttributeArgumentsSyntax.self)!
    }
    
    /// Checks if the current syntax node can be cast to ``DerivativeAttributeArgumentsSyntax``.
    ///
    /// - Returns: `true` if the node can be cast, `false` otherwise.
    public func `is`(_ syntaxType: DerivativeAttributeArgumentsSyntax.Type) -> Bool {
      return self.as(syntaxType) != nil
    }
    
    /// Attempts to cast the current syntax node to ``DerivativeAttributeArgumentsSyntax``.
    ///
    /// - Returns: An instance of ``DerivativeAttributeArgumentsSyntax``, or `nil` if the cast fails.
    public func `as`(_ syntaxType: DerivativeAttributeArgumentsSyntax.Type) -> DerivativeAttributeArgumentsSyntax? {
      return DerivativeAttributeArgumentsSyntax.init(self)
    }
    
    /// Force-casts the current syntax node to ``DerivativeAttributeArgumentsSyntax``.
    ///
    /// - Returns: An instance of ``DerivativeAttributeArgumentsSyntax``.
    /// - Warning: This function will crash if the cast is not possible. Use `as` to safely attempt a cast.
    public func cast(_ syntaxType: DerivativeAttributeArgumentsSyntax.Type) -> DerivativeAttributeArgumentsSyntax {
      return self.as(DerivativeAttributeArgumentsSyntax.self)!
    }
    
    /// Checks if the current syntax node can be cast to ``BackDeployedAttributeArgumentsSyntax``.
    ///
    /// - Returns: `true` if the node can be cast, `false` otherwise.
    public func `is`(_ syntaxType: BackDeployedAttributeArgumentsSyntax.Type) -> Bool {
      return self.as(syntaxType) != nil
    }
    
    /// Attempts to cast the current syntax node to ``BackDeployedAttributeArgumentsSyntax``.
    ///
    /// - Returns: An instance of ``BackDeployedAttributeArgumentsSyntax``, or `nil` if the cast fails.
    public func `as`(_ syntaxType: BackDeployedAttributeArgumentsSyntax.Type) -> BackDeployedAttributeArgumentsSyntax? {
      return BackDeployedAttributeArgumentsSyntax.init(self)
    }
    
    /// Force-casts the current syntax node to ``BackDeployedAttributeArgumentsSyntax``.
    ///
    /// - Returns: An instance of ``BackDeployedAttributeArgumentsSyntax``.
    /// - Warning: This function will crash if the cast is not possible. Use `as` to safely attempt a cast.
    public func cast(_ syntaxType: BackDeployedAttributeArgumentsSyntax.Type) -> BackDeployedAttributeArgumentsSyntax {
      return self.as(BackDeployedAttributeArgumentsSyntax.self)!
    }
    
    /// Checks if the current syntax node can be cast to ``ConventionAttributeArgumentsSyntax``.
    ///
    /// - Returns: `true` if the node can be cast, `false` otherwise.
    public func `is`(_ syntaxType: ConventionAttributeArgumentsSyntax.Type) -> Bool {
      return self.as(syntaxType) != nil
    }
    
    /// Attempts to cast the current syntax node to ``ConventionAttributeArgumentsSyntax``.
    ///
    /// - Returns: An instance of ``ConventionAttributeArgumentsSyntax``, or `nil` if the cast fails.
    public func `as`(_ syntaxType: ConventionAttributeArgumentsSyntax.Type) -> ConventionAttributeArgumentsSyntax? {
      return ConventionAttributeArgumentsSyntax.init(self)
    }
    
    /// Force-casts the current syntax node to ``ConventionAttributeArgumentsSyntax``.
    ///
    /// - Returns: An instance of ``ConventionAttributeArgumentsSyntax``.
    /// - Warning: This function will crash if the cast is not possible. Use `as` to safely attempt a cast.
    public func cast(_ syntaxType: ConventionAttributeArgumentsSyntax.Type) -> ConventionAttributeArgumentsSyntax {
      return self.as(ConventionAttributeArgumentsSyntax.self)!
    }
    
    /// Checks if the current syntax node can be cast to ``ConventionWitnessMethodAttributeArgumentsSyntax``.
    ///
    /// - Returns: `true` if the node can be cast, `false` otherwise.
    public func `is`(_ syntaxType: ConventionWitnessMethodAttributeArgumentsSyntax.Type) -> Bool {
      return self.as(syntaxType) != nil
    }
    
    /// Attempts to cast the current syntax node to ``ConventionWitnessMethodAttributeArgumentsSyntax``.
    ///
    /// - Returns: An instance of ``ConventionWitnessMethodAttributeArgumentsSyntax``, or `nil` if the cast fails.
    public func `as`(_ syntaxType: ConventionWitnessMethodAttributeArgumentsSyntax.Type) -> ConventionWitnessMethodAttributeArgumentsSyntax? {
      return ConventionWitnessMethodAttributeArgumentsSyntax.init(self)
    }
    
    /// Force-casts the current syntax node to ``ConventionWitnessMethodAttributeArgumentsSyntax``.
    ///
    /// - Returns: An instance of ``ConventionWitnessMethodAttributeArgumentsSyntax``.
    /// - Warning: This function will crash if the cast is not possible. Use `as` to safely attempt a cast.
    public func cast(_ syntaxType: ConventionWitnessMethodAttributeArgumentsSyntax.Type) -> ConventionWitnessMethodAttributeArgumentsSyntax {
      return self.as(ConventionWitnessMethodAttributeArgumentsSyntax.self)!
    }
    
    /// Checks if the current syntax node can be cast to ``OpaqueReturnTypeOfAttributeArgumentsSyntax``.
    ///
    /// - Returns: `true` if the node can be cast, `false` otherwise.
    public func `is`(_ syntaxType: OpaqueReturnTypeOfAttributeArgumentsSyntax.Type) -> Bool {
      return self.as(syntaxType) != nil
    }
    
    /// Attempts to cast the current syntax node to ``OpaqueReturnTypeOfAttributeArgumentsSyntax``.
    ///
    /// - Returns: An instance of ``OpaqueReturnTypeOfAttributeArgumentsSyntax``, or `nil` if the cast fails.
    public func `as`(_ syntaxType: OpaqueReturnTypeOfAttributeArgumentsSyntax.Type) -> OpaqueReturnTypeOfAttributeArgumentsSyntax? {
      return OpaqueReturnTypeOfAttributeArgumentsSyntax.init(self)
    }
    
    /// Force-casts the current syntax node to ``OpaqueReturnTypeOfAttributeArgumentsSyntax``.
    ///
    /// - Returns: An instance of ``OpaqueReturnTypeOfAttributeArgumentsSyntax``.
    /// - Warning: This function will crash if the cast is not possible. Use `as` to safely attempt a cast.
    public func cast(_ syntaxType: OpaqueReturnTypeOfAttributeArgumentsSyntax.Type) -> OpaqueReturnTypeOfAttributeArgumentsSyntax {
      return self.as(OpaqueReturnTypeOfAttributeArgumentsSyntax.self)!
    }
    
    /// Checks if the current syntax node can be cast to ``ExposeAttributeArgumentsSyntax``.
    ///
    /// - Returns: `true` if the node can be cast, `false` otherwise.
    public func `is`(_ syntaxType: ExposeAttributeArgumentsSyntax.Type) -> Bool {
      return self.as(syntaxType) != nil
    }
    
    /// Attempts to cast the current syntax node to ``ExposeAttributeArgumentsSyntax``.
    ///
    /// - Returns: An instance of ``ExposeAttributeArgumentsSyntax``, or `nil` if the cast fails.
    public func `as`(_ syntaxType: ExposeAttributeArgumentsSyntax.Type) -> ExposeAttributeArgumentsSyntax? {
      return ExposeAttributeArgumentsSyntax.init(self)
    }
    
    /// Force-casts the current syntax node to ``ExposeAttributeArgumentsSyntax``.
    ///
    /// - Returns: An instance of ``ExposeAttributeArgumentsSyntax``.
    /// - Warning: This function will crash if the cast is not possible. Use `as` to safely attempt a cast.
    public func cast(_ syntaxType: ExposeAttributeArgumentsSyntax.Type) -> ExposeAttributeArgumentsSyntax {
      return self.as(ExposeAttributeArgumentsSyntax.self)!
    }
    
    /// Checks if the current syntax node can be cast to ``OriginallyDefinedInAttributeArgumentsSyntax``.
    ///
    /// - Returns: `true` if the node can be cast, `false` otherwise.
    public func `is`(_ syntaxType: OriginallyDefinedInAttributeArgumentsSyntax.Type) -> Bool {
      return self.as(syntaxType) != nil
    }
    
    /// Attempts to cast the current syntax node to ``OriginallyDefinedInAttributeArgumentsSyntax``.
    ///
    /// - Returns: An instance of ``OriginallyDefinedInAttributeArgumentsSyntax``, or `nil` if the cast fails.
    public func `as`(_ syntaxType: OriginallyDefinedInAttributeArgumentsSyntax.Type) -> OriginallyDefinedInAttributeArgumentsSyntax? {
      return OriginallyDefinedInAttributeArgumentsSyntax.init(self)
    }
    
    /// Force-casts the current syntax node to ``OriginallyDefinedInAttributeArgumentsSyntax``.
    ///
    /// - Returns: An instance of ``OriginallyDefinedInAttributeArgumentsSyntax``.
    /// - Warning: This function will crash if the cast is not possible. Use `as` to safely attempt a cast.
    public func cast(_ syntaxType: OriginallyDefinedInAttributeArgumentsSyntax.Type) -> OriginallyDefinedInAttributeArgumentsSyntax {
      return self.as(OriginallyDefinedInAttributeArgumentsSyntax.self)!
    }
    
    /// Checks if the current syntax node can be cast to ``UnderscorePrivateAttributeArgumentsSyntax``.
    ///
    /// - Returns: `true` if the node can be cast, `false` otherwise.
    public func `is`(_ syntaxType: UnderscorePrivateAttributeArgumentsSyntax.Type) -> Bool {
      return self.as(syntaxType) != nil
    }
    
    /// Attempts to cast the current syntax node to ``UnderscorePrivateAttributeArgumentsSyntax``.
    ///
    /// - Returns: An instance of ``UnderscorePrivateAttributeArgumentsSyntax``, or `nil` if the cast fails.
    public func `as`(_ syntaxType: UnderscorePrivateAttributeArgumentsSyntax.Type) -> UnderscorePrivateAttributeArgumentsSyntax? {
      return UnderscorePrivateAttributeArgumentsSyntax.init(self)
    }
    
    /// Force-casts the current syntax node to ``UnderscorePrivateAttributeArgumentsSyntax``.
    ///
    /// - Returns: An instance of ``UnderscorePrivateAttributeArgumentsSyntax``.
    /// - Warning: This function will crash if the cast is not possible. Use `as` to safely attempt a cast.
    public func cast(_ syntaxType: UnderscorePrivateAttributeArgumentsSyntax.Type) -> UnderscorePrivateAttributeArgumentsSyntax {
      return self.as(UnderscorePrivateAttributeArgumentsSyntax.self)!
    }
    
    /// Checks if the current syntax node can be cast to ``DynamicReplacementAttributeArgumentsSyntax``.
    ///
    /// - Returns: `true` if the node can be cast, `false` otherwise.
    public func `is`(_ syntaxType: DynamicReplacementAttributeArgumentsSyntax.Type) -> Bool {
      return self.as(syntaxType) != nil
    }
    
    /// Attempts to cast the current syntax node to ``DynamicReplacementAttributeArgumentsSyntax``.
    ///
    /// - Returns: An instance of ``DynamicReplacementAttributeArgumentsSyntax``, or `nil` if the cast fails.
    public func `as`(_ syntaxType: DynamicReplacementAttributeArgumentsSyntax.Type) -> DynamicReplacementAttributeArgumentsSyntax? {
      return DynamicReplacementAttributeArgumentsSyntax.init(self)
    }
    
    /// Force-casts the current syntax node to ``DynamicReplacementAttributeArgumentsSyntax``.
    ///
    /// - Returns: An instance of ``DynamicReplacementAttributeArgumentsSyntax``.
    /// - Warning: This function will crash if the cast is not possible. Use `as` to safely attempt a cast.
    public func cast(_ syntaxType: DynamicReplacementAttributeArgumentsSyntax.Type) -> DynamicReplacementAttributeArgumentsSyntax {
      return self.as(DynamicReplacementAttributeArgumentsSyntax.self)!
    }
    
    /// Checks if the current syntax node can be cast to ``UnavailableFromAsyncAttributeArgumentsSyntax``.
    ///
    /// - Returns: `true` if the node can be cast, `false` otherwise.
    public func `is`(_ syntaxType: UnavailableFromAsyncAttributeArgumentsSyntax.Type) -> Bool {
      return self.as(syntaxType) != nil
    }
    
    /// Attempts to cast the current syntax node to ``UnavailableFromAsyncAttributeArgumentsSyntax``.
    ///
    /// - Returns: An instance of ``UnavailableFromAsyncAttributeArgumentsSyntax``, or `nil` if the cast fails.
    public func `as`(_ syntaxType: UnavailableFromAsyncAttributeArgumentsSyntax.Type) -> UnavailableFromAsyncAttributeArgumentsSyntax? {
      return UnavailableFromAsyncAttributeArgumentsSyntax.init(self)
    }
    
    /// Force-casts the current syntax node to ``UnavailableFromAsyncAttributeArgumentsSyntax``.
    ///
    /// - Returns: An instance of ``UnavailableFromAsyncAttributeArgumentsSyntax``.
    /// - Warning: This function will crash if the cast is not possible. Use `as` to safely attempt a cast.
    public func cast(_ syntaxType: UnavailableFromAsyncAttributeArgumentsSyntax.Type) -> UnavailableFromAsyncAttributeArgumentsSyntax {
      return self.as(UnavailableFromAsyncAttributeArgumentsSyntax.self)!
    }
    
    /// Checks if the current syntax node can be cast to ``EffectsAttributeArgumentListSyntax``.
    ///
    /// - Returns: `true` if the node can be cast, `false` otherwise.
    public func `is`(_ syntaxType: EffectsAttributeArgumentListSyntax.Type) -> Bool {
      return self.as(syntaxType) != nil
    }
    
    /// Attempts to cast the current syntax node to ``EffectsAttributeArgumentListSyntax``.
    ///
    /// - Returns: An instance of ``EffectsAttributeArgumentListSyntax``, or `nil` if the cast fails.
    public func `as`(_ syntaxType: EffectsAttributeArgumentListSyntax.Type) -> EffectsAttributeArgumentListSyntax? {
      return EffectsAttributeArgumentListSyntax.init(self)
    }
    
    /// Force-casts the current syntax node to ``EffectsAttributeArgumentListSyntax``.
    ///
    /// - Returns: An instance of ``EffectsAttributeArgumentListSyntax``.
    /// - Warning: This function will crash if the cast is not possible. Use `as` to safely attempt a cast.
    public func cast(_ syntaxType: EffectsAttributeArgumentListSyntax.Type) -> EffectsAttributeArgumentListSyntax {
      return self.as(EffectsAttributeArgumentListSyntax.self)!
    }
    
    /// Checks if the current syntax node can be cast to ``DocumentationAttributeArgumentListSyntax``.
    ///
    /// - Returns: `true` if the node can be cast, `false` otherwise.
    public func `is`(_ syntaxType: DocumentationAttributeArgumentListSyntax.Type) -> Bool {
      return self.as(syntaxType) != nil
    }
    
    /// Attempts to cast the current syntax node to ``DocumentationAttributeArgumentListSyntax``.
    ///
    /// - Returns: An instance of ``DocumentationAttributeArgumentListSyntax``, or `nil` if the cast fails.
    public func `as`(_ syntaxType: DocumentationAttributeArgumentListSyntax.Type) -> DocumentationAttributeArgumentListSyntax? {
      return DocumentationAttributeArgumentListSyntax.init(self)
    }
    
    /// Force-casts the current syntax node to ``DocumentationAttributeArgumentListSyntax``.
    ///
    /// - Returns: An instance of ``DocumentationAttributeArgumentListSyntax``.
    /// - Warning: This function will crash if the cast is not possible. Use `as` to safely attempt a cast.
    public func cast(_ syntaxType: DocumentationAttributeArgumentListSyntax.Type) -> DocumentationAttributeArgumentListSyntax {
      return self.as(DocumentationAttributeArgumentListSyntax.self)!
    }
  }
  
  public let _syntaxNode: Syntax
  
  public init?(_ node: some SyntaxProtocol) {
    guard node.raw.kind == .attribute else {
      return nil
    }
    self._syntaxNode = node._syntaxNode
  }
  
  /// - Parameters:
  ///   - leadingTrivia: Trivia to be prepended to the leading trivia of the node’s first token. If the node is empty, there is no token to attach the trivia to and the parameter is ignored.
  ///   - atSign: The `@` sign.
  ///   - attributeName: The name of the attribute.
  ///   - leftParen: If the attribute takes arguments, the opening parenthesis.
  ///   - arguments: The arguments of the attribute.
  ///   - rightParen: If the attribute takes arguments, the closing parenthesis.
  ///   - trailingTrivia: Trivia to be appended to the trailing trivia of the node’s last token. If the node is empty, there is no token to attach the trivia to and the parameter is ignored.
  public init(
      leadingTrivia: Trivia? = nil,
      _ unexpectedBeforeAtSign: UnexpectedNodesSyntax? = nil,
      atSign: TokenSyntax = .atSignToken(),
      _ unexpectedBetweenAtSignAndAttributeName: UnexpectedNodesSyntax? = nil,
      attributeName: some TypeSyntaxProtocol,
      _ unexpectedBetweenAttributeNameAndLeftParen: UnexpectedNodesSyntax? = nil,
      leftParen: TokenSyntax? = nil,
      _ unexpectedBetweenLeftParenAndArguments: UnexpectedNodesSyntax? = nil,
      arguments: Arguments? = nil,
      _ unexpectedBetweenArgumentsAndRightParen: UnexpectedNodesSyntax? = nil,
      rightParen: TokenSyntax? = nil,
      _ unexpectedAfterRightParen: UnexpectedNodesSyntax? = nil,
      trailingTrivia: Trivia? = nil
    
  ) {
    // Extend the lifetime of all parameters so their arenas don't get destroyed
    // before they can be added as children of the new arena.
    self = withExtendedLifetime((SyntaxArena(), (
            unexpectedBeforeAtSign, 
            atSign, 
            unexpectedBetweenAtSignAndAttributeName, 
            attributeName, 
            unexpectedBetweenAttributeNameAndLeftParen, 
            leftParen, 
            unexpectedBetweenLeftParenAndArguments, 
            arguments, 
            unexpectedBetweenArgumentsAndRightParen, 
            rightParen, 
            unexpectedAfterRightParen
          ))) { (arena, _) in
      let layout: [RawSyntax?] = [
          unexpectedBeforeAtSign?.raw, 
          atSign.raw, 
          unexpectedBetweenAtSignAndAttributeName?.raw, 
          attributeName.raw, 
          unexpectedBetweenAttributeNameAndLeftParen?.raw, 
          leftParen?.raw, 
          unexpectedBetweenLeftParenAndArguments?.raw, 
          arguments?.raw, 
          unexpectedBetweenArgumentsAndRightParen?.raw, 
          rightParen?.raw, 
          unexpectedAfterRightParen?.raw
        ]
      let raw = RawSyntax.makeLayout(
        kind: SyntaxKind.attribute,
        from: layout,
        arena: arena,
        leadingTrivia: leadingTrivia,
        trailingTrivia: trailingTrivia
        
      )
      return Syntax.forRoot(raw, rawNodeArena: arena).cast(Self.self)
    }
  }
  
  public var unexpectedBeforeAtSign: UnexpectedNodesSyntax? {
    get {
      return Syntax(self).child(at: 0)?.cast(UnexpectedNodesSyntax.self)
    }
    set(value) {
      self = Syntax(self).replacingChild(at: 0, with: Syntax(value), arena: SyntaxArena()).cast(AttributeSyntax.self)
    }
  }
  
  /// The `@` sign.
  ///
  /// ### Tokens
  /// 
  /// For syntax trees generated by the parser, this is guaranteed to be `@`.
  public var atSign: TokenSyntax {
    get {
      return Syntax(self).child(at: 1)!.cast(TokenSyntax.self)
    }
    set(value) {
      self = Syntax(self).replacingChild(at: 1, with: Syntax(value), arena: SyntaxArena()).cast(AttributeSyntax.self)
    }
  }
  
  public var unexpectedBetweenAtSignAndAttributeName: UnexpectedNodesSyntax? {
    get {
      return Syntax(self).child(at: 2)?.cast(UnexpectedNodesSyntax.self)
    }
    set(value) {
      self = Syntax(self).replacingChild(at: 2, with: Syntax(value), arena: SyntaxArena()).cast(AttributeSyntax.self)
    }
  }
  
  /// The name of the attribute.
  public var attributeName: TypeSyntax {
    get {
      return Syntax(self).child(at: 3)!.cast(TypeSyntax.self)
    }
    set(value) {
      self = Syntax(self).replacingChild(at: 3, with: Syntax(value), arena: SyntaxArena()).cast(AttributeSyntax.self)
    }
  }
  
  public var unexpectedBetweenAttributeNameAndLeftParen: UnexpectedNodesSyntax? {
    get {
      return Syntax(self).child(at: 4)?.cast(UnexpectedNodesSyntax.self)
    }
    set(value) {
      self = Syntax(self).replacingChild(at: 4, with: Syntax(value), arena: SyntaxArena()).cast(AttributeSyntax.self)
    }
  }
  
  /// If the attribute takes arguments, the opening parenthesis.
  ///
  /// ### Tokens
  /// 
  /// For syntax trees generated by the parser, this is guaranteed to be `(`.
  public var leftParen: TokenSyntax? {
    get {
      return Syntax(self).child(at: 5)?.cast(TokenSyntax.self)
    }
    set(value) {
      self = Syntax(self).replacingChild(at: 5, with: Syntax(value), arena: SyntaxArena()).cast(AttributeSyntax.self)
    }
  }
  
  public var unexpectedBetweenLeftParenAndArguments: UnexpectedNodesSyntax? {
    get {
      return Syntax(self).child(at: 6)?.cast(UnexpectedNodesSyntax.self)
    }
    set(value) {
      self = Syntax(self).replacingChild(at: 6, with: Syntax(value), arena: SyntaxArena()).cast(AttributeSyntax.self)
    }
  }
  
  /// The arguments of the attribute.
  /// 
  /// In case of user-defined attributes, such as macros, property wrappers or result builders,
  /// this is always either an `argumentList` of type ``LabeledExprListSyntax`` or `nil`.
  public var arguments: Arguments? {
    get {
      return Syntax(self).child(at: 7)?.cast(Arguments.self)
    }
    set(value) {
      self = Syntax(self).replacingChild(at: 7, with: Syntax(value), arena: SyntaxArena()).cast(AttributeSyntax.self)
    }
  }
  
  public var unexpectedBetweenArgumentsAndRightParen: UnexpectedNodesSyntax? {
    get {
      return Syntax(self).child(at: 8)?.cast(UnexpectedNodesSyntax.self)
    }
    set(value) {
      self = Syntax(self).replacingChild(at: 8, with: Syntax(value), arena: SyntaxArena()).cast(AttributeSyntax.self)
    }
  }
  
  /// If the attribute takes arguments, the closing parenthesis.
  ///
  /// ### Tokens
  /// 
  /// For syntax trees generated by the parser, this is guaranteed to be `)`.
  public var rightParen: TokenSyntax? {
    get {
      return Syntax(self).child(at: 9)?.cast(TokenSyntax.self)
    }
    set(value) {
      self = Syntax(self).replacingChild(at: 9, with: Syntax(value), arena: SyntaxArena()).cast(AttributeSyntax.self)
    }
  }
  
  public var unexpectedAfterRightParen: UnexpectedNodesSyntax? {
    get {
      return Syntax(self).child(at: 10)?.cast(UnexpectedNodesSyntax.self)
    }
    set(value) {
      self = Syntax(self).replacingChild(at: 10, with: Syntax(value), arena: SyntaxArena()).cast(AttributeSyntax.self)
    }
  }
  
  public static var structure: SyntaxNodeStructure {
    return .layout([
          \Self.unexpectedBeforeAtSign, 
          \Self.atSign, 
          \Self.unexpectedBetweenAtSignAndAttributeName, 
          \Self.attributeName, 
          \Self.unexpectedBetweenAttributeNameAndLeftParen, 
          \Self.leftParen, 
          \Self.unexpectedBetweenLeftParenAndArguments, 
          \Self.arguments, 
          \Self.unexpectedBetweenArgumentsAndRightParen, 
          \Self.rightParen, 
          \Self.unexpectedAfterRightParen
        ])
  }
}
