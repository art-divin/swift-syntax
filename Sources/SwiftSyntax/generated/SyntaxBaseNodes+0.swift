//// Automatically generated by generate-swift-syntax
//// Do not edit directly!
//===----------------------------------------------------------------------===//
//
// This source file is part of the Swift.org open source project
//
// Copyright (c) 2014 - 2023 Apple Inc. and the Swift project authors
// Licensed under Apache License v2.0 with Runtime Library Exception
//
// See https://swift.org/LICENSE.txt for license information
// See https://swift.org/CONTRIBUTORS.txt for the list of Swift project authors
//
//===----------------------------------------------------------------------===//

// MARK: - DeclSyntax

/// Protocol to which all ``DeclSyntax`` nodes conform.
///
/// Extension point to add common methods to all ``DeclSyntax`` nodes.
///
///  - Warning: Do not conform to this protocol yourself.
public protocol DeclSyntaxProtocol: SyntaxProtocol {}

/// Extension of ``DeclSyntaxProtocol`` to provide casting methods.
///
/// These methods enable casting between syntax node types within the same
/// base node protocol hierarchy (e.g., ``DeclSyntaxProtocol``).
///
/// While ``SyntaxProtocol`` offers general casting methods (``SyntaxProtocol.as(_:)``,
/// ``SyntaxProtocol.is(_:)``, and ``SyntaxProtocol.cast(_:)``), these often aren't
/// appropriate for use on types conforming to a specific base node protocol
/// like ``DeclSyntaxProtocol``. That's because at this level,
/// we know that the cast to another base node type (e.g., ``DeclSyntaxProtocol``
/// when working with ``ExprSyntaxProtocol``) is guaranteed to fail.
///
/// To guide developers toward correct usage, this extension provides overloads
/// of these casting methods that are restricted to the same base node type.
/// Furthermore, it marks the inherited casting methods from ``SyntaxProtocol`` as
/// deprecated, indicating that they will always fail when used in this context.
extension DeclSyntaxProtocol {
  /// Checks if the current syntax node can be cast to a given specialized syntax type.
  ///
  /// - Returns: `true` if the node can be cast, `false` otherwise.
  public func `is`<S: DeclSyntaxProtocol>(_ syntaxType: S.Type) -> Bool {
    return self.as(syntaxType) != nil
  }
  

  /// Attempts to cast the current syntax node to a given specialized syntax type.
  ///
  /// - Returns: An instance of the specialized type, or `nil` if the cast fails.
  public func `as`<S: DeclSyntaxProtocol>(_ syntaxType: S.Type) -> S? {
    return S.init(self)
  }
  

  /// Force-casts the current syntax node to a given specialized syntax type.
  ///
  /// - Returns: An instance of the specialized type.
  ///
  /// - Warning: This function will crash if the cast is not possible. Use `as` to safely attempt a cast.
  public func cast<S: DeclSyntaxProtocol>(_ syntaxType: S.Type) -> S {
    return self.as(S.self)!
  }
  

  /// Checks if the current syntax node can be upcast to its base node type (``DeclSyntax``).
  ///
  /// - Returns: `true` since the node can always be upcast to its base node.
  @available(*, deprecated, message: "This cast will always succeed")
  public func `is`(_ syntaxType: DeclSyntax.Type) -> Bool {
    return true
  }
  

  /// Attempts to upcast the current syntax node to its base node type (``DeclSyntax``).
  ///
  /// - Returns: The base node created from the current syntax node, as the node can always be upcast to its base type.
  @available(*, deprecated, message: "Use `DeclSyntax.init` for upcasting")
  public func `as`(_ syntaxType: DeclSyntax.Type) -> DeclSyntax? {
    return DeclSyntax(self)
  }
  

  /// Force-upcast the current syntax node to its base node type (``DeclSyntax``).
  ///
  /// - Returns: The base node created from the current syntax node, as the node can always be upcast to its base type.
  @available(*, deprecated, message: "Use `DeclSyntax.init` for upcasting")
  public func cast(_ syntaxType: DeclSyntax.Type) -> DeclSyntax {
    return DeclSyntax(self)
  }
  

  /// Checks if the current syntax node can be cast to a given node type from a base node protocol hierarchy other
  /// than ``DeclSyntaxProtocol``.
  ///
  /// - Returns: `true` if the node can be cast, `false` otherwise.
  ///
  /// - Note: In most cases, this is comparing a ``DeclSyntaxProtocol`` to a node that is not a
  ///   ``DeclSyntaxProtocol``, which will always fail. If the `syntaxType` argument is a generic type,
  ///   constrain it to ``DeclSyntaxProtocol`` instead of ``SyntaxProtocol``.
  @available(*, deprecated, message: "Type argument should be part of the 'DeclSyntaxProtocol' hierarchy")
  public func `is`<S: SyntaxProtocol>(_ syntaxType: S.Type) -> Bool {
    return self.as(syntaxType) != nil
  }
  

  /// Attempts to cast the current syntax node to a given node type from the a base node protocol hierarchy other than
  /// ``DeclSyntaxProtocol``.
  ///
  /// - Returns: An instance of the specialized type, or `nil` if the cast fails.
  ///
  /// - Note: In most cases, this is casting a ``DeclSyntaxProtocol`` to a node that is not a
  ///   ``DeclSyntaxProtocol``, which will always fail. If the `syntaxType` argument is a generic type,
  ///   constrain it to ``DeclSyntaxProtocol`` instead of ``SyntaxProtocol``.
  @available(*, deprecated, message: "Type argument should be part of the 'DeclSyntaxProtocol' hierarchy")
  public func `as`<S: SyntaxProtocol>(_ syntaxType: S.Type) -> S? {
    return S.init(self)
  }
  

  /// Force-casts the current syntax node to a given node type from a base node protocol hierarchy other than
  /// ``DeclSyntaxProtocol``.
  ///
  /// - Returns: An instance of the specialized type.
  ///
  /// - Warning: This function will crash if the cast is not possible. Use `as` to safely attempt a cast.
  ///
  /// - Note: In most cases, this is casting a ``DeclSyntaxProtocol`` to a node that is not a
  ///   ``DeclSyntaxProtocol``, which will always fail. If the `syntaxType` argument is a generic type,
  ///   constrain it to ``DeclSyntaxProtocol`` instead of ``SyntaxProtocol``.
  @available(*, deprecated, message: "Type argument should be part of the 'DeclSyntaxProtocol' hierarchy")
  public func cast<S: SyntaxProtocol>(_ syntaxType: S.Type) -> S {
    return self.as(S.self)!
  }
}

public extension Syntax {
  /// Check whether the non-type erased version of this syntax node conforms to
  /// DeclSyntaxProtocol.
  ///
  ///  - Note:  This will incur an existential conversion.
  func isProtocol(_: DeclSyntaxProtocol.Protocol) -> Bool {
    return self.asProtocol(DeclSyntaxProtocol.self) != nil
  }
  
  /// Return the non-type erased version of this syntax node if it conforms to
  /// DeclSyntaxProtocol. Otherwise return nil.
  ///
  ///  - Note:  This will incur an existential conversion.
  func asProtocol(_: DeclSyntaxProtocol.Protocol) -> DeclSyntaxProtocol? {
    return self.asProtocol(SyntaxProtocol.self) as? DeclSyntaxProtocol
  }
}

/// ### Subtypes
/// 
/// - ``AccessorDeclSyntax``
/// - ``ActorDeclSyntax``
/// - ``AssociatedTypeDeclSyntax``
/// - ``ClassDeclSyntax``
/// - ``DeinitializerDeclSyntax``
/// - ``EditorPlaceholderDeclSyntax``
/// - ``EnumCaseDeclSyntax``
/// - ``EnumDeclSyntax``
/// - ``ExtensionDeclSyntax``
/// - ``FunctionDeclSyntax``
/// - ``IfConfigDeclSyntax``
/// - ``ImportDeclSyntax``
/// - ``InitializerDeclSyntax``
/// - ``MacroDeclSyntax``
/// - ``MacroExpansionDeclSyntax``
/// - ``MissingDeclSyntax``
/// - ``OperatorDeclSyntax``
/// - ``PoundSourceLocationSyntax``
/// - ``PrecedenceGroupDeclSyntax``
/// - ``ProtocolDeclSyntax``
/// - ``StructDeclSyntax``
/// - ``SubscriptDeclSyntax``
/// - ``TypeAliasDeclSyntax``
/// - ``VariableDeclSyntax``
public struct DeclSyntax: DeclSyntaxProtocol, SyntaxHashable {
  public let _syntaxNode: Syntax
  
  /// Create a ``DeclSyntax`` node from a specialized syntax node.
  public init(_ syntax: some DeclSyntaxProtocol) {
    // We know this cast is going to succeed. Go through init(_: SyntaxData)
    // to do a sanity check and verify the kind matches in debug builds and get
    // maximum performance in release builds.
    self = Syntax(syntax).cast(Self.self)
  }
  
  /// Create a ``DeclSyntax`` node from a specialized optional syntax node.
  public init?(_ syntax: (some DeclSyntaxProtocol)?) {
    guard let syntax = syntax else {
      return nil
    }
    self.init(syntax)
  }
  
  public init(fromProtocol syntax: DeclSyntaxProtocol) {
    // We know this cast is going to succeed. Go through init(_: SyntaxData)
    // to do a sanity check and verify the kind matches in debug builds and get
    // maximum performance in release builds.
    self = Syntax(syntax).cast(Self.self)
  }
  
  /// Create a ``DeclSyntax`` node from a specialized optional syntax node.
  public init?(fromProtocol syntax: DeclSyntaxProtocol?) {
    guard let syntax = syntax else {
      return nil
    }
    self.init(fromProtocol: syntax)
  }
  
  public init?(_ node: some SyntaxProtocol) {
    switch node.raw.kind {
    case .accessorDecl, .actorDecl, .associatedTypeDecl, .classDecl, .deinitializerDecl, .editorPlaceholderDecl, .enumCaseDecl, .enumDecl, .extensionDecl, .functionDecl, .ifConfigDecl, .importDecl, .initializerDecl, .macroDecl, .macroExpansionDecl, .missingDecl, .operatorDecl, .poundSourceLocation, .precedenceGroupDecl, .protocolDecl, .structDecl, .subscriptDecl, .typeAliasDecl, .variableDecl:
      self._syntaxNode = node._syntaxNode
    default:
      return nil
    }
  }
  
  /// Syntax nodes always conform to `DeclSyntaxProtocol`. This API is just
  /// added for consistency.
  ///
  ///  - Note:  This will incur an existential conversion.
  @available(*, deprecated, message: "Expression always evaluates to true")
  public func isProtocol(_: DeclSyntaxProtocol.Protocol) -> Bool {
    return true
  }
  
  /// Return the non-type erased version of this syntax node.
  ///
  ///  - Note:  This will incur an existential conversion.
  public func asProtocol(_: DeclSyntaxProtocol.Protocol) -> DeclSyntaxProtocol {
    return Syntax(self).asProtocol(DeclSyntaxProtocol.self)!
  }
  
  public static var structure: SyntaxNodeStructure {
    return .choices([
          .node(AccessorDeclSyntax.self),
          .node(ActorDeclSyntax.self),
          .node(AssociatedTypeDeclSyntax.self),
          .node(ClassDeclSyntax.self),
          .node(DeinitializerDeclSyntax.self),
          .node(EditorPlaceholderDeclSyntax.self),
          .node(EnumCaseDeclSyntax.self),
          .node(EnumDeclSyntax.self),
          .node(ExtensionDeclSyntax.self),
          .node(FunctionDeclSyntax.self),
          .node(IfConfigDeclSyntax.self),
          .node(ImportDeclSyntax.self),
          .node(InitializerDeclSyntax.self),
          .node(MacroDeclSyntax.self),
          .node(MacroExpansionDeclSyntax.self),
          .node(MissingDeclSyntax.self),
          .node(OperatorDeclSyntax.self),
          .node(PoundSourceLocationSyntax.self),
          .node(PrecedenceGroupDeclSyntax.self),
          .node(ProtocolDeclSyntax.self),
          .node(StructDeclSyntax.self),
          .node(SubscriptDeclSyntax.self),
          .node(TypeAliasDeclSyntax.self),
          .node(VariableDeclSyntax.self)
        ])
  }
}

/// Protocol that syntax nodes conform to if they don't have any semantic subtypes.
/// These are syntax nodes that are not considered base nodes for other syntax types.
///
/// Syntax nodes conforming to this protocol have their inherited casting methods
/// deprecated to prevent incorrect casting.
public protocol _LeafDeclSyntaxNodeProtocol: DeclSyntaxProtocol {}

public extension _LeafDeclSyntaxNodeProtocol {
  /// Checks if the current leaf syntax node can be cast to a different specified type.
  ///
  /// - Returns: `false` since the leaf node cannot be cast to a different specified type.
  ///
  /// - Note: This method overloads the general `is` method and is marked as deprecated to produce a warning,
  ///         informing the user that the cast will always fail.
  @available(*, deprecated, message: "This cast will always fail")
  func `is`<S: DeclSyntaxProtocol>(_ syntaxType: S.Type) -> Bool {
    return false
  }
  

  /// Attempts to cast the current leaf syntax node to a different specified type.
  ///
  /// - Returns: `nil` since the leaf node cannot be cast to a different specified type.
  ///
  /// - Note: This method overloads the general `as` method and is marked as deprecated to produce a warning,
  ///         informing the user that the cast will always fail.
  @available(*, deprecated, message: "This cast will always fail")
  func `as`<S: DeclSyntaxProtocol>(_ syntaxType: S.Type) -> S? {
    return nil
  }
  

  /// Force-casts the current leaf syntax node to a different specified type.
  ///
  /// - Returns: This method will always trigger a runtime crash and never return.
  ///
  /// - Note: This method overloads the general `cast` method and is marked as deprecated to produce a warning,
  ///         informing the user that the cast will always fail.
  /// - Warning: Invoking this method will lead to a fatal error.
  @available(*, deprecated, message: "This cast will always fail")
  func cast<S: DeclSyntaxProtocol>(_ syntaxType: S.Type) -> S {
    fatalError("\(Self.self) cannot be cast to \(S.self)")
  }
}
